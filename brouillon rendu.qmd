---
title: "Brouillon rendu"
format: 
  html:
    citeproc: false
    filters:
      - "citeproc.lua"
      - "wordcount.lua"
editor: visual
author: "jacopo hilde leopold"
code-fold: true
---

# Introduction
Text Text

```{r, eval = FALSE}

#pour pouvoir convertir le markdown en pdf sans latex (il faut l'enlever du document une fois qu'on l'a installé)

install.packages('tinytex')
tinytex::install_tinytex()  # install TinyTeX
```

```{r, echo = FALSE, message = FALSE}

rm(list=ls(all=TRUE))
library(ggplot2)
library(vroom)
library(dplyr)
library(tidyr)
library(knitr)
library(here)
library(plotly)
library(here)
library(tidyverse)
library(cartogram)
library(sf)
library(tidyverse)
library(spData)
library(tmap)
library(cartogram)


# Importation des donnees:
here::i_am("M2SES.Rproj")

Annuaire <- vroom("fr-en-annuaire-education.csv")
ParcourSup <- vroom("fr-esr-parcoursup.csv")
Eloignement <- vroom("fr-en-indice_eloignement_lycee_ap2020.csv")

IPS <- vroom("fr-en-ips_lycees.csv")
IPS_2022_2023 <- vroom("fr-en-ips-lycees-ap2022.csv")
IPS_2023_2024 <- vroom("fr-en-ips-lycees-ap2023.csv")

IVAL_gt <- vroom("fr-en-indicateurs-de-resultat-des-lycees-gt_v2.csv")

# les donnees pour le Geoplot selon les regions
st_layers("France_entiere.gpkg")
region <- st_read("France_entiere.gpkg", layer="region")
region <- region |> rename(region="nom_officiel_en_majuscules")

# les donnees pour le Geoplot selon les communes (seulement France metropolitaine parce que trop compliqué de zoomé dans la carte complete)
st_layers("Carto_France.gpkg")
communes <- st_read("Carto_France.gpkg", layer="commune")
communes <- communes |> rename(commune="nom_officiel_en_majuscules")


#transformer un d.f en objet sf --> st_as_sf(objet):
IVAL_gt <-IVAL_gt %>% filter(Année == 2016 | Année==2020 | Année==2024)

#faire pivoter les IVAL pour les avoirs en colomne et se débarraser des lignes par années:
IVAL_gt <- IVAL_gt %>% rename(IVAL = `Valeur ajoutée du taux de réussite - Toutes séries`) 

IVAL_gt %>%
  count(UAI) %>%
  filter(n > 1)

IVAL_gt <- IVAL_gt %>% select(UAI, Année, IVAL, Secteur, `Taux d'accès 2nde-bac`, `Taux de réussite - Toutes séries`) %>%
  mutate(secteur_public = if_else(Secteur == "public", 1, 0)) %>% select(-Secteur) %>%
    pivot_wider(
    names_from = Année,
    values_from = c(IVAL, `Taux d'accès 2nde-bac`, `Taux de réussite - Toutes séries` ),
    names_glue = "{.value}_{Année}"
  )

IVAL_gt %>%
  count(UAI) %>%
  filter(n > 1)


#Pareil pour l'éloignement:
Eloignement <- Eloignement %>% filter(Année=="2020" | Année=="2024" ) %>%  select(UAI, Année, `Indice éloignement` ) %>%
    pivot_wider(
    names_from = Année,
    values_from = `Indice éloignement`,
    names_glue = "{.value}_{Année}"
  ) 


Eloignement %>%
  count(UAI) %>%
  filter(n > 1)



# Unifier le tables IPS
IPS_pivot_2016 <- IPS |> select(`Rentrée scolaire`, UAI, `IPS voie GT`, Secteur) |>
  pivot_wider(id_cols = UAI, names_from = 'Rentrée scolaire',
              values_from = 'IPS voie GT', , names_prefix = "IPS ")

IPS_pivot_2022 <- IPS_2022_2023 |> select(`Rentrée scolaire`, UAI, `IPS voie GT`) |>
  pivot_wider(id_cols = UAI, names_from = 'Rentrée scolaire',
              values_from = 'IPS voie GT', , names_prefix = "IPS ")

IPS_pivot_2024 <- IPS_2023_2024 |> select(`Rentrée scolaire`, UAI, `IPS voie GT`) |>
  pivot_wider(id_cols = UAI, names_from = 'Rentrée scolaire',
              values_from = 'IPS voie GT', , names_prefix = "IPS ")


IPS_gt <- IPS_pivot_2016 |> left_join(IPS_pivot_2022) |> left_join(IPS_pivot_2024) |> filter(!is.na(`IPS 2016-2017`)) %>% select(`IPS 2016-2017`, `IPS 2020-2021`,`IPS 2024-2025`, UAI )


IPS_gt %>%
  count(UAI) %>%
  filter(n > 1)


IVAL_IPS_gt <- inner_join(IVAL_gt,IPS_gt, by = "UAI")

IVAL_IPS_gt %>%
  count(UAI) %>%
  filter(n > 1)

IVAL_IPS_gt <- IVAL_IPS_gt %>% inner_join(Eloignement, by = "UAI")

#remettre les communes mtn.

IVAL_gt <- vroom("fr-en-indicateurs-de-resultat-des-lycees-gt_v2.csv")

IVAL_gt <- IVAL_gt %>% 
  filter(Année %in% c(2016, 2020, 2024)) %>% 
  select(UAI, Region, Département, Académie, Commune, `Code commune`) %>% 
  distinct(UAI, .keep_all = TRUE)

IVAL_gt %>%
  count(UAI) %>%
  filter(n > 1)

IVAL_IPS_gt <- IVAL_IPS_gt %>% inner_join(IVAL_gt, by = "UAI")





# on n'a pas besoin de la suite, c'est ca?
********************
IVAL_IPS_gt <- IVAL_IPS_gt %>% inner_join(Eloignement, by = "UAI")

#remettre les communes mtn.

IVAL_gt <- vroom("fr-en-indicateurs-de-resultat-des-lycees-gt_v2.csv")

IVAL_gt <- IVAL_gt %>% 
  filter(Année %in% c(2016, 2020, 2024)) %>% 
  select(UAI, Region, Département, Académie, Commune, `Code commune`) %>% 
  distinct(UAI, .keep_all = TRUE)

IVAL_gt %>%
  count(UAI) %>%
  filter(n > 1)

IVAL_IPS_gt <- IVAL_IPS_gt %>% inner_join(IVAL_gt, by = "UAI")

```
# Regression
montrer qu'il y a une causalité entre le IPS et le IVAL?

```{r)
# @ Leopold, si tu veux partager le code que t'as fait pour la regression, je pense que ca pourrait etre un bon point de depart du rendu

```

# Eloignement

```{r}

# Indice moyen d'éloignement par académie pour 2024 ?
# je propose qu'on enleve ca, parce-que on n'arrive pas a faire le geoplot avec les academies, et c'est un peu double avec eloignement sur region

Eloi2024_Acad <- IVAL_IPS_gt %>% group_by(Académie)  %>% summarise(moyenne_eloignement_2024 = mean(`Indice éloignement_2024`, na.rm = TRUE)) 
  
ggplot(Eloi2024_Acad, aes(x = fct_reorder(Académie, moyenne_eloignement_2024), 
           y = moyenne_eloignement_2024, 
           fill = moyenne_eloignement_2024)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(
    title = "Indice moyen d'éloignement par académie (2024)",
    x = "Académie",
    y = "Indice moyen"
  ) + theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}

# Indice moyen d'éloignement par region pour 2024 ?

Eloi2024_Reg <- IVAL_IPS_gt |> group_by(Region)  |> summarize(moyenne_eloignement_2024 = mean(`Indice éloignement_2024`, na.rm = TRUE)) |> rename(region="Region") 
  
ggplot(Eloi2024_Reg, aes(x = fct_reorder(region, moyenne_eloignement_2024), 
           y = moyenne_eloignement_2024, 
           fill = moyenne_eloignement_2024)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(
    title = "Indice moyen d'éloignement par region (2024)",
    x = "Region",
    y = "Indice moyen"
  ) + theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
# Visualisation des Geodonnees en relation avec l'eloignement

## Indice moyen d'eloignement par Region en 2024 pour toute la France: 
```{r}
# Indice moyen d'eloignement par Region pour 2024 (geoplot) - pour toute la France 
# jsp si on veut garder ca, c'est un peu moche

region_eloi <- region |> select(region, code_insee, code_siren, geometrie) |> right_join(Eloi2024_Reg, by="region")
tm_shape(region_eloi) + tm_fill(fill="moyenne_eloignement_2024",
                             fill.scale=tm_scale_intervals(values="kovesi.blue", n=10,
                                                           style="quantile"))
```

## Indice moyen d'eloignement par Region en 2024 pour la France metropolitaine: 
```{r}
# Indice moyen d'eloignement par Region pour 2024 (geoplot) metropol: 

metropole <- region_eloi |> 
  filter(!code_insee %in% c("01","02","03","04","06"))
tm_shape(metropole) + tm_fill(fill="moyenne_eloignement_2024",
                             fill.scale=tm_scale_intervals(values="kovesi.blue", n=10,
                                                           style="quantile")) + tm_layout(frame =FALSE, component.autoscale = FALSE)

```

## Indice moyen d'eloignement par Region en 2024 pour la France outre mer: 
```{r}
# Indice moyen d'eloignement par Region pour 2024 (geoplot) - pour la France outre mer 

outremer <- region_eloi |> 
  filter(code_insee %in% c("01","02","03","04","06"))
tm_shape(outremer) + tm_fill(fill="moyenne_eloignement_2024",
                             fill.scale=tm_scale_intervals(values="kovesi.blue", n=10,
                                                           style="quantile")) + tm_layout(frame =FALSE, component.autoscale = FALSE)

```


# IVAL

```{r}
# IVAL selon les communes 2016 (geoplot) ?
#

IVAL_2016 <- IVAL_IPS_gt |> rename(commune="Commune") |> select(IVAL_2016, commune) 

IVAL_communes <- communes |>  select(commune, code_insee, geometrie) |> right_join(IVAL_2016, by="commune") 


tm_shape(IVAL_communes) + tm_fill(fill="IVAL_2016",
                             fill.scale=tm_scale_intervals(values="kovesi.blue", n=5
                                                           style="quantile")) + tm_layout(frame =FALSE, component.autoscale = FALSE)
```

# Public et privé

```{r}

# nombre de lycées privés par académie.
# cette partie ne fonctionne pas encore si je la mets en r studio, notamment parce que la variable secteur_public n'est pas dans le df

priv_acad <- IVAL_IPS_gt %>%
  filter(secteur_public == 0) %>%         
  group_by(Académie) %>%
  summarise(nb_prives = n()) 

ggplot(priv_acad, aes(x=fct_reorder(Académie,nb_prives), y=nb_prives, fill=nb_prives)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}
#IPS moyen par Académie. Peut être qu'il faut recflechir à des pondérations...
IVAL_IPS_gt <- IVAL_IPS_gt %>%
  mutate(IPS_moy_lycee = rowMeans(
    select(., `IPS 2016-2017`, `IPS 2020-2021`, `IPS 2024-2025`),
    na.rm = TRUE
  ))

IPS_acad <- IVAL_IPS_gt %>%
  group_by(Académie) %>%
  summarise(IPS_moyen = mean(IPS_moy_lycee, na.rm = TRUE))

IPS_acad %>% ggplot(aes(x=fct_reorder(Académie,IPS_moyen), y=IPS_moyen, fill=IPS_moyen)) + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
